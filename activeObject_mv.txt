// ActiveObejct.cpp : This file contains the 'main' function. Program execution begins and ends there.
// This is implementation of Active Object Numbers Queue.
// -------------------------------------------------------------------------------------------------------------------------------------- //
// The Client is trying to put new number in Number Queue until Queue is full. Also Client is trying to get number form queue (pop out).
// Besides main thread there are two extra threads (T1 and T2).

// Thread 1 (T1) creates new Method Requests and puts them in the Activation Queue. In case when we want to put certain number in queue 
// of numbers (Servant), Method Request is created and stored in Method Request queue. This thread informs second thread that there is 
// some Method Requests in queue. After that Thread 2 (T2)  starts to check is Servant (queue of numbers) ready to receive another number 
// and if this is true the new number is added in the queue of numbers. 
// In a case when we want to pop out certain number from queue, Thread 1 do that.
// -------------------------------------------------------------------------------------------------------------------------------------- //

#include <iostream>
#include <string>
#include <vector>
#include <chrono>
#include <thread>
#include <mutex>

#include <Windows.h>

typedef std::string Message;
std::condition_variable cond;

class MQ_Servant {
public:
	MQ_Servant(int q_size) : queue_size(q_size) {}

	void put(int number)
	{
		queue.push_back(number); // adding new number in queue

		if (queue.size() > queue_size)
		{
			full_i = true;
		}
		else
		{
			full_i = false;
		}
		if (!queue.empty())
		{
			empty_i = false;
		}
	}

	void get(int &number)
	{
		number = queue.back();
		queue.pop_back(); // pop out last number from queue
		if (queue.empty())
		{
			empty_i = true;
		}
	}

	bool full_i = false;
	bool empty_i = true;
private:
	std::vector<int> queue; int queue_size;

};

class Method_Request
{
public:
	virtual bool guard(void) = 0;
	virtual void call(void) = 0;
};

class Put : public Method_Request
{
public:
	Put(MQ_Servant *rep, int arg) : m_servant(rep), number(arg) {}

	virtual bool guard(void)
	{
		// check if Servant is full
		return m_servant->full_i;
	}

	virtual void call(void)
	{
		std::cout << "T2: Putting the new number: " << number << " in queue of numbers." << std::endl;
		m_servant->put(number);
	}

private:
	MQ_Servant *m_servant; int number;
};

class Get : public Method_Request
{
public:
	Get(MQ_Servant *rep) : m_servant(rep){}

	virtual bool guard(void)
	{
		// check if Servant is full
		return m_servant->empty_i;
	}

	virtual void call(void)
	{
		m_servant->get(std::ref(numberFromQueue));
		std::cout << "T1: Getting (pop out) the new number: " << numberFromQueue << " from queue." << std::endl;
	}

protected:
	int numberFromQueue;
private:
	MQ_Servant *m_servant; int number;
};

class Activation_Que
{
public:
	Activation_Que(int q_size) {}

	void enqueue(Method_Request *method_request)
	{
		// put new Method Request in Activation Queue
		m_mrVect.push_back(method_request);
	}

	void dequeue(Method_Request *method_request)
	{
		// remove Method Request from the queue
		for (Method_Request * mt_req : m_mrVect)
		{
			// check if Servant is ready for new Method Request
			if (mt_req == method_request)
			{
				int index = std::find(std::begin(m_mrVect), std::end(m_mrVect), mt_req) - std::begin(m_mrVect);
				m_mrVect.erase(std::begin(m_mrVect) + index);
			}
		}
	}

	std::vector<Method_Request *> return_mrVect()
	{
		return m_mrVect;
	}
private:
	std::vector<Method_Request *> m_mrVect;

};

class MQ_Scheduler {
public:
	MQ_Scheduler(int q_size) : m_actQueue(new Activation_Que(q_size)){}

	void enqueue(Method_Request *method_request)
	{
		m_actQueue->enqueue(method_request);
	}

	void get_number_from_queue(Method_Request *method_request)
	{
		if (!method_request->guard())
		{
			method_request->call();
		}
		else
		{
			std::cout << "T1: There is no any number in queue of numbers to get (pop out)." << std::endl;
		}
	}

	void svc_run()
	{
		m_mrVect = m_actQueue->return_mrVect(); // returning current queue
		this->dispatch();
	}

	void dispatch(void)
	{
		// iteration through all Activation Queue
		// check if Servant is ready for new Method Request - take first method request from the queue
		if (!m_mrVect.empty())
		{
			mt_req = m_mrVect.front();
			if (!mt_req->guard())
			{
				mt_req->call();
				m_actQueue->dequeue(mt_req);
				delete mt_req;
			}
			else
			{
				std::cout << "The queue is full!" << std::endl;
			}
			m_mrVect = m_actQueue->return_mrVect();
		}
		else
		{
			std::cout << "T2: There are no any Method Request in Activation Queue. Activation Queue size: " << m_mrVect.size() << std::endl;
		}
	}
private:
	Activation_Que *m_actQueue; std::vector<Method_Request *> m_mrVect; std::condition_variable cond; Method_Request *mt_req;
};

class MQ_Proxy
{
public:
	MQ_Proxy(int q_size) : m_scheduler(new MQ_Scheduler(q_size)), m_servant(new MQ_Servant(q_size)) {}

	void put(int number)
	{
		Method_Request *method_Request = new Put(m_servant, number);
		m_scheduler->enqueue(method_Request);
	}
	void get()
	{
		Method_Request *method_Request = new Get(m_servant);
		m_scheduler->get_number_from_queue(method_Request);
	}
protected:
	MQ_Servant *m_servant;
public:
	MQ_Scheduler *m_scheduler;
};

void start_thread_for_method_request(MQ_Proxy &proxy)
{
	std::mutex mu;
	
	int count = 10;
	while (count > 0)
	{
		std::unique_lock<std::mutex> locker(mu);
		cond.wait(locker);
		proxy.m_scheduler->svc_run();
		locker.unlock();
		std::this_thread::sleep_for(std::chrono::seconds(1));
		count--;		
	}
}

void start_thread_for_queue(MQ_Proxy &proxy)
{
	std::mutex mu;
	int random_num;

	int count = 11;
	while (count > 0)
	{
		random_num = std::rand() % 10; // randomly decide to put number in queue or take number from queue
		if (random_num < 8)
		{
			// try to put number in queue
			std::unique_lock<std::mutex> locker(mu);
			std::cout << "T1: Adding number " << count << " in the request queue (Method Request queue)." << std::endl;
			proxy.put(count);
			locker.unlock();
			cond.notify_one(); // notify Thread 2 that there is Method Requests in queue and to try to put than number in queue of numbers
			std::this_thread::sleep_for(std::chrono::seconds(2));
		}
		else
		{
			// get number from queue
			std::unique_lock<std::mutex> locker(mu);
			proxy.get();
			locker.unlock();
			cond.notify_one(); // notify Thread 2 that there are Method Requests in queue
			std::this_thread::sleep_for(std::chrono::seconds(2));
		}
		count--;
	}
}

int main()
{
	std::cout << "CREATING PROXY!" << std::endl;
	int queue_size = 30;
	MQ_Proxy proxy(queue_size);

	// STARTING NEW THREADSs
	std::thread t1(start_thread_for_queue, std::ref(proxy)); // first side thread
	std::thread t2(start_thread_for_method_request, std::ref(proxy)); //second side thread
	t1.join();
	t2.join();
	system("pause");

	return 0;
}
